# C-programming-

데이터 분석 자격증+sqld 자격증 따기!!


지금까지 배운 함수들

getchar() - 버퍼에서 '한'글자 가져옴
putchar()-  '한'글자 출력
gets -보한 결함 사용 x
gets_s()


많이 쓰는 형식 문자
%c - int char
%f - double
%s- string
%d- int
%y- unsigned interger


13. 배열과 프로그래밍 기법

배열(Array):  형식이 같은(동일 타입의 데이터)를 '하나'의 이름으로 묶어 하나의 '변수'로 관리하는 구조
-여러 요소를 식별하기 위해 index 사용 , 0부터 시작 (zero-based index)
-배열의 이름: 0번 요소의 메모리 주소에 대한 식별자(상수) (R-value)

문자 배열(문자열),(char[])
-문자열의 끝은 반드시 (null)
-문자열 상수는 보통 포인터를 사용해 관리

버블 정렬(지속적 교환)
-정렬이 끝났으면 비교 index(idx)를 옮기는 게 point

선택 정렬
-제일 작은 값의 idx를 찾아놓고 바로바로 바꾸는 것이 아니라,
바깥쪽 loop 하나 돌 때 한 번씩 바꾸기
-탐색 범위에서 index만 찾아놓고, 탐색이 끝나면 한 번만 교환

다차원 배열
- [행][열] //two dimension 배열까지 밖에 안씀, 3차원 쓰는 거 못봄
-숫자 채우기,, ++cnt, index값 홀수? 짝수?, 규칙성

look up 배열 (탐색 배열)
- 데이터를 검색 혹은 참조하기 위해 사용
- 입력값을 이용해 계산 없이 바로 원하는 결과값의 위치를 찾아내는 방식
- 조건문처럼 순차적으로 체크할 필요가 없어서 성능이 good
-----------------------------------------------------------------------------------------------------------------------

14.함수 기본 이론

사용자 정의 함수
(구조: 반환자료형 이름(매개변수 목록))
-절차적 흐름을 갖는 여러 구문을 하나로 묶어 사용하는 단위코드
-여러 함수가 존재할 경우 '호출'(call)을 통해 연결(bind) 
-호출자와 피호출자 함수로 관계를 규정한다(binding 되어있다)
-호출자는 피호출자 함수'의' 매개변수 '초깃값'을 기술해야할 의무가 있음.
-피호출자 함수는 호출자 함수에게 값을 '반환'
-main 함수의 시작과 끝이 곧 프로그램의 시작과 끝
-main() -caller -> Add()-callee

//알아두기
SDK: software development kit
API: Aplication programming interface//  함수 시그니처(선언) + 타입 정의 + 매크로(상수) + 문서
SDK에는 lib의 집합체 lib 안에는 다양한 함수들 API 

함수 설계 원칙
-UI(user interface)와 기능은 분리
- 재사용 가능한 단위 코드는 함수로 구현 (DRY 원칙), 복붙해서 또 쓸 것만 같은.. 느느낌 

식별자 (이름)
-변수
-배열 <-0번 요소의 메모리 주소에 대한 식별자
-함수  <- 기계어(실행코드)가 저장된 메모리의 주소

event loop
(사용자 입력(key, mouse) 때문에 이벤트 발생--> 처리)
-main() 함수에서 사용자 '인터페이스 출력' 및 '사용자 입력'을 '반복'하는 구조
-보통 메뉴와 사용자 선택 확인( 메뉴선택에 따른 기능들)
-'대부분'의 응용 프로그램이 채택하는 일반적인 구조 

함수 원형 선언 
ex int main(void) ; -> 그냥 선언만 해놓은 거임
-함수의 선언과 정의를 분리
-함수 바디 없이 원형만 기술할 경우 함수 시그니처라고 불림
-매개변수 이름은 생략 가능하다.
-컴파일러에게 함수의 존재를 알리기 위해,, 분리한 선언을 코드 상단에 기술
ex) int add(int, int) //선언  
int main(void) printf~~ }

int add( int x, int y){
return x+y} //함수 정의

분할 컴파일-링크 오류 주의  
- 1개의 project의 여러개의 소스코드 .c 파일을 운영하는 경우 각각 개별 컴파일
 -개별 소스코드에 대한 목적 .obj 파일 형성
main에다가 add 함수 선언 해주고 다른 .c 파일에 정의해주면 오류 X
OR 헤더파일에 func.h 만들어서 int add(int int) 선언후
 main에서 #include "func.h" 도 가능
-변수나 함수 선언과 정의가 다른 파일로 분리 될 수 있음. 

전역변수와 식별자 검색 순서 // 전역변수는 되도록이면 쓰지 않는데, 쓴다면 g_ 써주자 
-전역변수는 함수 바디 '밖에' 선언
식별자 검색 순서(1.지역 스코프 2. 최대 함수바디 3. 최대 로컬 파일 4. 외부파일까지 확장)
//같은 이름이 있다면 지역변수가 전역변수보다 우선 참조됨//식별자 검색 순서-지역 스코프

-----------------------------------------------------
15. 메모리와 포인터

*컴퓨터와 메모리
-메모리하면 변수, 고유주소(모든 메모리는 고유주소(byte)를 가짐)
-64bit 시스템 , 메모리 주소 길이는 64bit

*메모리 종류
-stack, heap(동적 할당 메모리, malloc, free), 실행코드(data section(문자열 상수, 정적메모리)
, text section(실행코드 기계어)) //문자열 상수는 실행 코드 일부인 PE 파일 안에 문자열로 저장되어있다.
-지역변수: 스코프 내부
-자동변수: stack에 저장되고 '함수'가 끝나면 자동으로 사라짐 // 말 그대로 자동 //함수 호출시 stack에 저장 되고 함수 반환하면 (종료) 스택 프레임 해제 되면서변수 접근불가 
//대부분의 지역변수는 자동변수임, static지역변수 빼고 static은 프로그램 끝날 때까지..
//모든 자동변수는 지역변수임 


*메모리 관리 함수
malloc(), calloc(인자개수,sizeof(int)) - 0초기화 동적할당 동시에, realloc(), free()
memcpy(), strcpy() 
memcmp(), strcmp()
sprintf()
memset(시작주소,채워넣을값,채울바이트수) //0초기화가 꼭 필요한 건 아닌데 
//문자열 저장시 사용 추천 -> string.h 헤더파일 추가


*windows 가상 메모리 시스템
Vms(virtual memory space) 
-주기억장치 RAM과 보조기억장치 HDD, SSD(solid state drive)를 하나의 논리 메모리로 추상화 한 것이 VMS
-sw: 시스템 sw, 응용 program

*포인터 변수(pointer)
- 메모리 주소를 저장하기 위한 전용 변수
-64bit 시스템에서 주소상수, 포인터 변수는 모두 64bit(8byte)

*직접 지정과 간접 지정
직접지정: 메모리 주소가 고정되어 있고, 변화가 적은 정적 데이터 (전역변수, 상수테이블) 
간접지정: 실행 중에 위치가 변할 수 있는 데이터 (포인터, 동적할당, 연결 구조체, 리스트)
 
*포인터 1차원 배열
-포인터 변수나 배열 이름에 대해 덧셈, 뺄셈 연산 가능(산술 연산이 아니라 상대 위치 계산) //배열 요소의 개수를 의미한다.
-포인터 변수에 대해서는 단항 증감 연산 가능 
ex) char szBuffer[32]={"you are~~}  szbuffer[0]=*szBuffer=*(szBuffer+0) 이거 세개가 같음 %c로 찍어보면 *szBuffer가 가르키는 것.. 
&szBuffer[4]=&*(szBuffer+4)=szBuffer+4 // 이건 셋다 주소 //배열의 이름은 기준주소
간접지정과 주소연산은 반대니까 상충된다. 사라짐 


*메모리 동적 할당 및 관리 
-heap영역을 사용하는 방법
-프로그램 실행중(runtime)중 필요한 메모리를 OS에 요청(할당), 반환(해제)의 책임이 있다.
-할당 받은 메모리는 쓰레기 값이 들어있을 수도 있음 (clear, 필수는 아님) 

*메모리 값 복사 
-배열에 대해서는 단순 대입 연산으로 copy 불가능 
-반복문을 통해 개별 요소를 하나씩 복사하는 정석적인 방법 -> memcpy(dest주소,현 주소, 복사할byte수 ) 

*문자열 복사
strcpy_s(dest,dest_size,src) // 문자열주소 pszBuffer 포인터에 저장하고  따로 pszHeap을 만들어서 pszBuffer를 pszHeap에 string copy 하는 방식. 
dest:문자열을 복사해서 저장할 버퍼
dest_size: dest 버퍼의 전체 크기(byte)
src: 복사할 원본 문자열(널 종료문자열)  

*realloc() //realloc(기존에할당받은메모리주소, 늘리고 싶은 메모리 크기 ex 32) 
만약 주소가 같으면 늘리는 거 성공 ! 
-기존에 할당 받은 메모리의 크기를 조정해 다시 할당
-메모리 chunk 크기 조절 실패 경우 새로운 위치로 이동 
-잘안씀 참고만



*알아두면 좋을 것..
-ASLR( Address space layout randomization) : 주소공간배치 난수화
//ASLR이 없을 때는 프로그램이 실행될 때 스택, 힙, 라이브러리 위치가 항상 같았음
//운영체제 자체적으로 ASLR을 실행해서 주소를 특정 못하게 stack과 heap 주소 위치 변경

- int aList[5]={0}; //이제 int가 4byte니까 메모리 공간 20byte인거 보여야함
//디버그 모드시 메모리 창에 4개씩 끊어서 20byte로 생각

sigle pointer와 arr의 호환성
-int aList[5], int*pnData가 있을 때,
 pnData=&aList[0] // aList ; 
*pnData=20 // pnData[0]=20이라고 써도됨 

-


